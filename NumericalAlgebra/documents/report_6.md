# 作业报告五
 - 陈泽高 PB20000302
## 代码结构：
 - 本次作业的代码结构较为简单。由于不需要与前面的 ```Solver```合并，因此我将主要功能写在了新的文件```ImplictQR.cpp```中，且只引用了之前的```Function.hpp```中两个函数，其他的都可以不用检查
 - 本次作业含有三部分代码，名称及功能如下：
    1. Function.hpp/cpp:
    这次仅调用了生成Householder变换的函数```funs::householder()```以及便于输出矩阵和向量新编写的函数```out::output()```
    2. ImplictQR.hpp/cpp:
        实现幂法求方程模最大根的函数```Find_largest_root()```。为了实现效率最大化，其中的迭代步骤是根据多项式友阵的形式特点制定的，因此不能用于一般的幂法求特征值问题
    
        实现Francis双重步位移隐式QR算法的函数```Implict_qr()```。其中生成Householder变换的函数从```Function.hpp```调用，算法管线中其余函数均在相同文件中，详见源代码注释
    3. Homework6.cpp:
        调用前述函数完成本次作业并展示，详见源代码注释

 - 此外，在注释中还保留了若干测试痕迹，审阅时可以利用它们来测试代码；还有部分可调整参数，可以改变运行速度和精度。

## 幂法求多项式模最大根
 - **问题描述：**
 求解多项式方程 $$ f(x)=a_0+a_1x+a_2x^2+...+a_{n-1}x^{n-1}+x^n=0 $$ 的模最大根
 - **算法原理：**
 1. 多项式的友阵
 $$ 
    A = \begin{pmatrix}
    -p_{n-1} & -p_{n-2} & \cdots &  -p_{1} & -p_{0} \\
    1 & 0 & \cdots & 0 & 0 \\
    0 & 1 & \cdots & 0 & 0 \\
    \vdots & \vdots & \ddots & \vdots & \vdots \\
    0 & 0 & \cdots & 1 & 0 \\
    \end{pmatrix} 
 $$ 的特征多项式恰好为$f(x)$，即 $A$ 的全体特征值即为 $f(x)$ 的根。因此对 $A$ 应用幂法即可

 2. 幂法可以较便捷地求取矩阵的模最大特征值及其对应的特征向量，这里只需要求特征值。
 对于矩阵$A$， 取 $ u\in \R^{n} $ ，使得它在$A$的模最大特征值的特征子空间中的投影不为$0$，则通过下面的迭代过程可以得到其模最大特征值
 $$
    v=Au \\
    \mu = argmax_{\mu=v_i} |\mu| \\
    u = v/\mu \\
 $$
 本题算法中 $Au$ 的计算被简化，减少迭代次数，详见源代码
 注意到所选取的初始值$u$有可能恰好不满足投影条件，因此可以通过随机选取或者交叉验证来避免这样的问题
 
 - **实验结果与分析：**
 如图所示，算法运行比较高效，计时间隔非常小，且与参考结果十分接近。
    <center>
        <img src="screenshots/exe1_debug.jpg" style="zoom: 90%;" />
    </center>
    
    这三题的最大根与次大根模的比值分别为 $3/1=3$，$ 1.879/1.532 = 1.227$，$ 100/10 = 10$，因此第三题所需迭代次数最少，第一题次之，第二题迭代次数最多，印证了“最大模与次大模的比值越大，收敛速度越快”的结论

## 求矩阵的全体特征值
 - **问题描述：**
 求矩阵$A$的全体特征值（特征向量）

 - **算法原理：**
 采用Francis双重步位移隐式QR算法，将$A$正交相似为实Schur阵，然后根据该Schur阵求解其特征值（与特征向量），算法流程见教材**算法6.4.3**或查阅文件```ImplictQR.hpp/cpp```中的函数```Implict_qr()```，此处不再赘述。

 - **实验结果与分析：**
    1. 求多项式方程的所有根：
        <center>
        <img src="screenshots/exe2_1.jpg" style="zoom: 60%;" />
        </center>
    参考解如下（对比结果十分接近）：
        <center>
        <img src="screenshots/exe2_1_refer.jpg" style="zoom: 60%;" />
        </center>
    
    2. 求矩阵的全部特征值，及其随其中某变元的变化
        <center>
        <img src="screenshots/exe2_2.jpg" style="zoom: 60%;" />
        </center>
    参考解如下（对比结果十分接近）：
        <center>
        <img src="screenshots/exe2_2_refer.jpg" style="zoom: 60%;" />
        </center>
    
    矩阵$A$的特征值随$x$缓慢变化，$x$增大时，其较大的实特征值的模长增大，较小特征值的模长减小，复特征值的模长增大。

    可以看出结果准确度较高，迭代次数在合理范围（$O(n)$，$n$为矩阵规模）（且运行速度很快），任务完成度高。

### 经验总结
 由于本次实验中，隐式QR算法的流程繁琐冗长，在前期没有规划好的情况下，中间多次出现householder变换但想要调用已有的变换函数未果，而且每次都不得不重新写一遍，这极大地提高了错误率，导致笔者在调试过程花费了大量时间。
 之后笔者将整理已有的```Function```函数库以及增加更具普适性的功能函数（例如矩阵乘法，适用于局部操作的householder变换等），为将来的程序编写提供基础素材。
 模块化编程有利于局部的代码测试，提高调试效率，之后笔者也会将程序更合理地划分模块，方便程序编写、测试和增删。