# 2. 高效的动态数组

> **Efficient** **D**ynamic **Array** (EfficientDArray)
>
> ---
>
> **注：** 如果你正在接受这些编程训练，表示你已经同意我们之间的版权协议。请严禁将这些练习的代码（包括你自己的代码）在不经允许的情况下在公共网上公布和散播。一经发现，后果自负。谢谢！－刘利刚 (ligang.liu@gmail.com)

## 问题

现在实现的类基本满足一个“动态数组”的要求，用户能很方便的使用它。

但是，这个动态数组的使用也有问题，比如，每当数组的元素个数发生变化时，总是要发生内存的释放和申请的操作，这个使得操作效率上非常低效，并且很容易产生内存碎片。想象一下如果用户是不断用`push_back()` 函数来增加 10000 个元素，程序是如何的运行？

如何能改进它呢？

一个想法就是预先多分配一些内存，然后在相当一段时间内，当数组的元素个数发生变化时，不用重新申请内存空间，数组也能继续使用。这样就提高了效率。

对于机器算法中，“时间”和“空间”的矛盾总是存在的：存储多一点，运行就快些；存储少了，运行就慢些。在这里就体现了，这样处理是用空间换时间。虽然在内存空间上是“浪费”了部分的空间，但是在很长一段时间里，只要空间没有发生变化，运行的时间复杂度就恒定的。只有当现有的空间不够用时，才发生内存的重新申请和释放操作。最简单的增长方法就是增长一倍，即乘以 2，这样内存分配的大小就是 2 的幂次方。

因此，我们加上一个 `m_nMax` 数据，用以存储所申请到的内存空间大小，而 `m_nSize` 才真正记录这个数组的元素个数。类的接口为：[DArray.h](../../project/src/executables/2_EfficientDArray/DArray.h) 

注意，在这里只增加了一个数据 `m_nMax`，其他的所有函数接口都没有发生改变！对用户来将，仍然是按照以前的习惯使用接口函数来操作动态数组，但是本质上这个动态数组的操作效率大大是提高了！

> **Remark** 
>
> c++ 标准要求，即使在请求分配 0 字节内存时，`operator new` 也要返回一个合法指针，`int* p = new int [0]` 是合理的，`delete p` 也是合理的，
> 但是不能对 `p` 指向的空间进行操作，比如 `p[0] = 0`，这会引发新的内存分配，再进行 `delete` 操作时就会出错：*Heap corruption detected* 

## 作业要求

- 完成满足上述接口的动态数组(Dynamic array)的程序，递交项目文件（不含文件夹 `build/`， `bin/` 和 `lib/`，只需包含原有文件夹和 `CMakeLists.txt`）
- 严格遵循基本的编程规范和风格；
- 体会类的接口确定了，其实现可以不一样：用户只跟类（对象）的接口打交道，具体是通过哪些数据来实现的是不关心的
- 进一步熟悉和体会 C++ 类的封装特性；
- 学会用 Visual Studio 2019 的 debug 工具来调试程序，掌握几个关键的快捷键（F5, F10, F11, F9 等）调试方法，详细见附带的“VC 编程调试工具”；
- 仍使用以前的测试代码，做更多充分的测试，体会到处理各种极端情况需要更多的代码和调试时间。

